# -*- coding: utf-8 -*-
"""mecs6616-Spring2023-Project3-ql2465.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_D4WvTGeXULB4h4I7tWTW1U3Bnqy5Gxk

# ***Important***

**Before starting, make sure to read the [Assignment Instructions](https://courseworks2.columbia.edu/courses/172081/pages/assignment-instructions) page on Courseworks2 to learn the workflow for completing this project.**

**Different from Projects 1 and 2**, apart from the link to your notebook, you are also required to submit the collected data file `data.pkl` and your chosen model checkpoint `dynamic.pth` to Coursework. You should put the link to your notebook in the "Comment" section of your submission.

# Project Setup
"""

# DO NOT CHANGE

# After running this cell, the folder 'mecs6616_sp23_project3' will show up in the file explorer on the left (click on the folder icon if it's not open)
# It may take a few seconds to appear
!git clone https://github.com/roamlab/mecs6616_sp23_project3.git

# DO NOT CHANGE

# Copy all needed files into the working directory. This is simply to make accessing files easier
!cp -av /content/mecs6616_sp23_project3/* /content/

# DO NOT CHANGE

# Install required packages
!pip install ray

"""# Starter Code Explanation

This project uses two 3-link arms, one called arm_teacher (blue) and the other called arm_student (red), as shown in the image below. For each test, a constant torque will be applied to the first joint of both arms for 5 seconds. arm_teacher is moving according to the provided ground truth forward dynamics and your job is to use deep learning to train the arm_student to learn the forward dynamics of the arm_teacher so that it can imitate its behavior. The forward dynamics is a function that takes in the current state of and an action applied to the arm, and then computes the new state of the arm. This project uses a time step of 0.01 second, meaning each time we advance the simulation, we compute the forward dynamics for 0.01 second. In the example image, the student arm is not updating its state and remains static but we will make it move after training is done.



<div>
<img src="https://github.com/roamlab/mecs6616_sp23_project3/blob/master/imgs/example.png?raw=true" width="600"/>
</div>

The interface for controlling the robot is defined in the `Robot` class in `robot.py` file. Each robot is initialized with a corresponding forward dynamics (the base class for forward dynamics definition is in `arm_dynamic_base.py`). The arm_teacher is initialized with the provided ground truth forward dynamics, as defined in `arm_dynamics_teacher.py`. You are welcome to look in-depth into this file to understand how the ground truth forward dynamics is computed for an arm, given its number of links, link mass, and viscous friction of the environment - this is recommended but not necessary to successfully complete this assignment. The state of each arm is defined with a (6,1)-dimensional numpy array (three joint positions in radians + three joint velocities in radians per second). An action is defined as the three toques (in Nm) applied to the three joints respectively, which is a (3,1) numpy array. **Throughout this project, we make the problem simpler by only applying a torque to the first joint, so the actions always look like `[torque,0,0]`.** Also, when scoring your model the robot will always start off in a hanging position, meaning an initial state of `[-pi/2,0,0,0,0,0]` so if the collected data from part 1 looks similar, the model will perform better. The `robot.py` file provides you with some functions to set/get the state and set the action for the arm. Make sure you understand `robot.py` well enough before getting started.

`geometry.py` provides some geometry functions and `render.py` defines how the visualization is rendered. These two files are not of particular interest for completing this project.

# Part I. Data collection.

You will first need to complete the cell below to collect a dataset for training the forward dynamics. After running the cell, it should generate a pickle file `data.pkl` that contains a data dictionary `data = {'X': X, 'Y': Y}`. The shape of `data['X']` should be (`num_samples`, 9), the first 6 elements are state and the last 3 elements are the action. The shape of `data['Y']` should be (`num_samples`, 6), which saves the next state after applying the action using the ground truth forward dynamics of arm_teacher.

**After the data file is generated, `data.pkl` should appear under the 'Files' icon in the left sidebar. You can download this file by right clicking the file name. You are required to submit this file. Please do not change its name.**

In the cell below, we have provided a minimal example of simulating the arm_teacher for 5 seconds. The GUI visualization is turned on and you should see the behavior of arm_teacher. The visualization can drastically slow down the simulator and you should turn it off when collecting a large amount of data.
"""

import numpy as np
import os
from arm_dynamics_teacher import ArmDynamicsTeacher
from robot import Robot
import pickle
import math
from render import Renderer
import time
import ray

# DO NOT CHANGE
# Teacher arm
dynamics_teacher = ArmDynamicsTeacher(
    num_links=3,
    link_mass=0.1,
    link_length=1,
    joint_viscous_friction=0.1,
    dt=0.01
)
arm_teacher = Robot(dynamics_teacher)

# ---
# You code starts here. X and Y should eventually be populated with your collected data
# Control the arm to collect a dataset for training the forward dynamics.
# ray.shutdown()
# ray.init()

# @ray.remote(num_returns = 2, num_cpus = 2)
def collect():
    num_data = 625
    num_steps = 800
    X = np.zeros((num_data*num_steps, arm_teacher.dynamics.get_state_dim() + arm_teacher.dynamics.get_action_dim()))
    Y = np.zeros((num_data*num_steps, arm_teacher.dynamics.get_state_dim()))



    torque = 1.5*(1-2*np.random.rand(num_data))


    for i in range(num_data):
        print(i)
        initial_state = np.zeros((arm_teacher.dynamics.get_state_dim(), 1))  # position + velocity
        initial_state[0] = -math.pi / 2.0
        arm_teacher.set_state(initial_state)
        action = np.zeros((arm_teacher.dynamics.get_action_dim(), 1))
        # action[0] = torque[i]
        action[0] = -1.5 + 3.0* i/num_data
        # print(action)
        arm_teacher.set_action(action)

        for j in range(num_steps):
            X[i*num_steps+j,0:6] = arm_teacher.get_state().flatten()
            X[i*num_steps+j,6:9] = action.flatten()

            arm_teacher.advance()
            Y[i*num_steps+j,:6] = arm_teacher.get_state().flatten()

    return X, Y
    # We run the simulator for 5 seconds with a time step of 0.01 second,
    # so there are 500 steps in total

X, Y = collect()

# GUI visualization, this will drastically reudce the speed of the simulator!
gui = False

# Define the initial state of the robot, such that it is vertical
initial_state = np.zeros((arm_teacher.dynamics.get_state_dim(), 1))  # position + velocity
initial_state[0] = -math.pi / 2.0

# Set the initial state of the arm. Input to set_state() should be of shape (6, 1)
arm_teacher.set_state(initial_state)

# Define the action, applying 1Nm torque to the first joint
action = np.zeros((arm_teacher.dynamics.get_action_dim(), 1))
action[0] = 1

# Set the action. Input to set_action() should be of shape (3, 1)
arm_teacher.set_action(action)

# Initialize the GUI
if gui:
    renderer = Renderer()
    time.sleep(1)

num_steps = 500
for s in range(num_steps):
    # Get the current state
    state = arm_teacher.get_state()

    # The advance function will simulate the action for 1 time step
    arm_teacher.advance()
    if gui:
        renderer.plot([(arm_teacher, 'tab:blue')])

    # Get the new state after advancing one time step
    new_state = arm_teacher.get_state()
# ---

# DO NOT CHANGE
# Save the collected data in the data.pkl file
data = {'X': X, 'Y': Y}
pickle.dump(data, open( "data.pkl", "wb" ) )
# print(data)

"""# Part 2. Learning the forward dynamics.

## Training

After the data is collected, you will then need to complete the cell below to use the collected dataset to learn the forward dynamics.

The code already creates the dataset class and loads the dataset with a random 0.8/0.2 train/test split for you. This cell should save the model that it trains. You should use a specific procedure for saving, outlined below.

In machine learning, it is a very good practice to save not only the final model but also the checkpoints, such that you have a wider range of models to choose from. We provide a code snippet for you and for each epoch of your training, you should use it to save the model at that epoch.

```
model_folder_name = f'epoch_{epoch:04d}_loss_{test_loss:.8f}'
if not os.path.exists(os.path.join(model_dir, model_folder_name)):
    os.makedirs(os.path.join(model_dir, model_folder_name))
torch.save(model.state_dict(), os.path.join(model_dir, model_folder_name, 'dynamics.pth'))
```

The output from running this code should be a folder as below:

```
models/
    2023-03-08_23-57-50/
        epoch_0001_loss_0.00032930/
            dynamics.pth
        epoch_0002_loss_0.00009413/
            dynamics.pth   
        ...  
```

You can see that every time you run this cell, a folder whose name is the time you started will be created under `models`. Checkpoints from all epochs will be saved and then the folder name for saving the checkpoint indicates the epoch number and loss on the holdout test set. Recording checkpoints this way allows you to easily pick the model with the smallest loss.

### Important: choosing the best model

Your code should keep track of the checkpoint with the smallest loss on the test set. You should save the path of that checkpoint to the variable `model_path`. An example value of `model_path` could be `models/2023-03-07_20-14-32/epoch_0046_loss_0.00000005/dynamics.pth`. In the evaluation code, the checkpoint from `model_path` will be loaded and evaluated.

You should also download the `dynamic.pth` file to include in your submission.
"""

import torch
from torch.utils.data import Dataset, DataLoader, random_split
import os
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import argparse
import time
import pickle
import ray.train as train
# from ray.train import Trainer
np.set_printoptions(suppress=True)


class DynamicDataset(Dataset):
    def __init__(self, data_file):
        data = pickle.load(open(data_file, "rb" ))
        # X: (N, 9), Y: (N, 6)
        self.X = data['X'].astype(np.float32)
        self.Y = data['Y'].astype(np.float32)

    def __len__(self):
        return self.X.shape[0]

    def __getitem__(self, idx):
        return self.X[idx], self.Y[idx]


class Net(nn.Module):
    def __init__(self, dt):
        super().__init__()
        self.dt = dt

    def forward(self, x):
        acc = self.compute(x)
        state = x[:, :6]
        next_state = self.compute_obs(acc, state)
        return next_state

    def compute_obs(self, acc, state):
        dt = self.dt
        velo_old = state[:, 3:6]
        velo_new = velo_old + acc * torch.tensor(dt)
        angle_old = state[:, :3]
        angle_new = angle_old + torch.tensor(0.5) * (velo_old + velo_new) * torch.tensor(dt)
        next_state = torch.cat([angle_new, velo_new], dim=1)
        return next_state

    def compute(self, x):
        pass


class network(Net):
    def __init__(self, dt):
        super().__init__(dt)
        self.fc1 = nn.Linear(9, 64)
        # self.fc2 = nn.Linear(1024, 512)
        # self.fc3 = nn.Linear(512, 128)
        self.fc4 = nn.Linear(64, 32)
        self.fc5 = nn.Linear(32, 3)

    def compute(self, x):
        x = F.relu(self.fc1(x))
        # x = F.relu(self.fc2(x))
        # x = F.relu(self.fc3(x))
        x = F.relu(self.fc4(x))
        x = self.fc5(x)
        return x


def train(model, train_loader, total_train):
    model.train()

    learning_rate = 0.0005
    optimizer = torch.optim.Adam(model.parameters(),lr = learning_rate)
    criterion = nn.MSELoss()
    # scheduler = ExponentialLR(self.optimizer, gamma=0.99)
    # scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, factor=0.95, patience=5, verbose=True, min_lr=1e-5)

    total_loss = 0.0
    for i, data in enumerate(train_loader):
        features = data[0]
        labels = data[1]
        optimizer.zero_grad()
        predictions = model(features)
        loss = criterion(predictions, labels)
        loss.backward()
        total_loss += loss.item()
        optimizer.step()
        # print(i)
    # scheduler.step(total_loss)



def test(model, test_loader, total_test):
    model.eval()
    criterion = nn.MSELoss()
    test_loss = 0
    # ---
    for i, data in enumerate(test_loader):
        feature = data[0]
        label = data[1]
        predictions = model(feature)
        print(predictions.shape)
        loss= criterion(predictions, label)
        test_loss += loss.item()
        cur_loss = test_loss/(i+1)

    print(f"epoch:{epoch} loss:{cur_loss}")
    return cur_loss


# The ratio of the dataset used for testing
split = 0.2

# We are only using CPU, and GPU is not allowed.
device = torch.device("cpu")

dataset = DynamicDataset('data.pkl')
dataset_size = len(dataset)
test_size = int(np.floor(split * dataset_size))
train_size = dataset_size - test_size
train_set, test_set = random_split(dataset, [train_size, test_size])


train_loader = torch.utils.data.DataLoader(train_set, batch_size=150, shuffle=True)
test_loader = torch.utils.data.DataLoader(test_set, batch_size=150, shuffle=True)
total_train = train_set.__len__()
total_test = test_set.__len__()
# print(len(test_loader.sampler))
# The name of the directory to save all the checkpoints
timestr = time.strftime("%Y-%m-%d_%H-%M-%S")
model_dir = os.path.join('models', timestr)

# Keep track of the checkpoint with the smallest test loss and save in model_path
model_path = None

epochs = 25
loss = float('inf')
# trainer = Trainer(backend = "torch", num_worker = 4)
# trainer.start()
model = network(0.01)
for epoch in range(1, 1 + epochs):

    train(model, train_loader, total_train)

    test_loss = test(model, test_loader, total_test)
    if test_loss < loss:
        loss = test_loss
        best = epoch
        model_folder_name = f'epoch_{epoch:04d}_loss_{test_loss:.8f}'
        if not os.path.exists(os.path.join(model_dir, model_folder_name)):
            os.makedirs(os.path.join(model_dir, model_folder_name))
        torch.save(model.state_dict(), os.path.join(model_dir, model_folder_name, 'dynamics.pth'))
print(best)

"""## Prediction

After you are done with training, you need to complete the cell below to load the saved checkpoint (in function init_model) and then use it to predict the new state given the current state and action (in function dynamics_step). Please do not modify the arguments to those functions, even though you might not use all of them.
"""

# model_path = "/content/models/2023-03-30_15-19-44/epoch_0004_loss_0.00000025/dynamics.pth"
# model_path ="/content/models/2023-03-30_15-47-20/epoch_0027_loss_0.00000031/dynamics.pth"
# model_path ="/content/models/2023-03-30_16-33-16/epoch_0001_loss_0.00000036/dynamics.pth"
# model_path = "/content/models/2023-03-30_16-36-55/epoch_0001_loss_0.00000021/dynamics.pth"
model_path = "/content/models/2023-03-30_17-10-50/epoch_0018_loss_0.00000017/dynamics.pth"

from arm_dynamics_base import ArmDynamicsBase

class ArmDynamicsStudent(ArmDynamicsBase):
    def init_model(self, model_path, num_links, time_step, device):
        # ---
        # Your code hoes here
        # Initialize the model loading the saved model from provided model_path
        self.model = network(time_step)
        # ---
        self.model_loaded = True
        best_check_point = torch.load(model_path)
        self.model.load_state_dict(best_check_point)

    def dynamics_step(self, state, action, dt):
        if self.model_loaded:
            self.model.eval()
            state = np.array(state).reshape(1, -1)
            action = np.array(action).reshape(1, -1)
            X_predict = np.concatenate((state, action), axis=1)
            # print(X_predict.shape)
            new_state = self.model(torch.from_numpy(X_predict).float()).detach().numpy()

            return new_state.reshape(-1, 1)

            # ---
        else:
            return state

"""# Evaluation and Grading

The total number of points for this project is 15. There are 3 types of tests, each is worth 5 points.

**For each type, there are 50 tests.** For each test, you get a score of 1, 0.5, or 0. Your final grade for each type is the averaged score across 50 tests * 5.

- *Type 1*: for each test, a constant torque randomly sampled from [-1.5Nm, 1.5Nm] is applied to the first joint of the arm for 5 seconds. If the MSE (Mean Squred Error) between the predicted arm state (arm_student) and the ground truth arm state (arm_teacher) is < 0.0005, you get score 1 for this test. If 0.0005 <= MSE < 0.008, you get score 0.5 for this test. Otherwise you get 0.
- *Type 2*: for each test, a torque that linearly increases from 0 to a random torque in [0.5Nm, 1.5Nm] is applied to the first joint of the arm for 5 seconds. If MSE < 0.0005, you get score 1 for this test. If 0.0005 <= MSE < 0.008, you get score 0.5 for this test. Otherwise you get 0.
- *Type 3*: for each test, one torque is applied for the first 2.5 seconds and another torque is applied for the remaining 2.5 seconds. Both torques are sampled from [-1Nm, 1Nm]. If MSE < 0.015, you get score 1 for this test. If 0.015 <= MSE < 0.05, you get score 0.5 for this test. Otherwise you get 0.

"""

# DO NOT CHANGE
# Set up grading

# Make sure model_path is correctly set

print(model_path)

import importlib
import score
importlib.reload(score)

# Create the teacher arm
dynamics_teacher = ArmDynamicsTeacher(
    num_links=3,
    link_mass=0.1,
    link_length=1,
    joint_viscous_friction=0.1,
    dt=0.01
)
arm_teacher = Robot(dynamics_teacher)

# Create the student arm
dynamics_student = ArmDynamicsStudent(
    num_links=3,
    link_mass=0.1,
    link_length=1,
    joint_viscous_friction=0.1,
    dt=0.01
)
if model_path is not None:
  dynamics_student.init_model(model_path, num_links=3, time_step=0.01, device=torch.device('cpu'))
arm_student = Robot(dynamics_student)

# DO NOT CHANGE

# Test on randomly sampled torques from [-1.5, 1.5]
score.score_random_torque(arm_teacher, arm_student, gui= False)

# DO NOT CHANGE

# Test on torques that linearly increase from 0 to a random number from [0.5, 1.5]
score.score_linear_torques(arm_teacher, arm_student, gui=False)

# DO NOT CHANGE

# Test on one torque applied to the first 2.5s and another torque applied to the second 2.5s
# Both torques are sampled from [-1, 1]
score.score_two_torques(arm_teacher, arm_student, gui=False)

"""# Other Requirements and Hints

- Training time: This project requires more training than the previous projects. But less than ▶ **hundred epochs of training (<= 25 mins)** should suffice for achieving the full points. Again, the shorter your model training time is the better.
- Dataset: Choosing the right policy to collect datasets for this project is important. You need to think about how to do it properly so that your trained model will pass the tests successfully. It is in general very hard to learn the ground truth forward dynamics completely (that works for any distribution of actions), and during testing small errors can accumulate, leading to drastic failure in the end. You might want to try ▶**overfitting** on the test cases, to begin with. Make sure that your dataset is ▶**less than 100 Mb**, which is pretty much sufficient for achieving full marks. Collecting datasets can be time-consuming and you could parallelize this process for some speed-up using [ray](https://www.ray.io/). Make sure your data collection takes <= 25 mins.
- NO GPU: No GPU is required or allowed for this assignment and we will test your code without GPUs.
- Loss Function: This is essentially a regression problem so think about what losses are suitable for regression.
- Optimizer: While it is possible to use a simple optimizer to achieve the desired accuracy, the training time can be quite high. There exists a number of optimizers implemented in PyTorch that have much faster convergence.
- Seeding. Please use seeding in your code to make sure your results are reproducible.
"""

